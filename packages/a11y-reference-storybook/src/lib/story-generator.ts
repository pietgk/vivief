/**
 * Story Generator
 *
 * Generates Storybook stories from axe-core rule metadata and fixtures.
 * Stories include a11yReference parameters for validation.
 */

import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import type { AxeRuleMetadata } from "./axe-rule-extractor.js";
import type { ExtractedFixture } from "./fixture-extractor.js";

/**
 * Options for story generation
 */
export interface StoryGeneratorOptions {
  /** Output directory for generated stories */
  outputDir: string;
  /** Whether to overwrite existing files */
  force?: boolean;
  /** Whether to generate MDX documentation */
  generateDocs?: boolean;
  /** Dry run - don't write files */
  dryRun?: boolean;
}

/**
 * Generated story file info
 */
export interface GeneratedStory {
  /** Rule ID */
  ruleId: string;
  /** File path relative to output directory */
  filePath: string;
  /** Story category */
  category: string;
  /** Number of violation stories */
  violationCount: number;
  /** Number of pass stories */
  passCount: number;
  /** Whether file was written (false if dry run or skipped) */
  written: boolean;
}

/**
 * Result of story generation
 */
export interface GenerationResult {
  /** Generated stories */
  stories: GeneratedStory[];
  /** Total number of stories generated */
  totalStories: number;
  /** Number of files written */
  filesWritten: number;
  /** Number of files skipped (already exist) */
  filesSkipped: number;
  /** Any errors encountered */
  errors: string[];
}

/**
 * Category mapping for rules
 */
const RULE_CATEGORIES: Record<string, string> = {
  // Images
  "image-alt": "images",
  "input-image-alt": "images",
  "svg-img-alt": "images",
  "role-img-alt": "images",
  "object-alt": "images",

  // Buttons
  "button-name": "buttons",
  "input-button-name": "buttons",

  // Links
  "link-name": "links",
  "link-in-text-block": "links",

  // Forms
  label: "forms",
  "select-name": "forms",
  "autocomplete-valid": "forms",

  // Color
  "color-contrast": "color",
  "color-contrast-enhanced": "color",

  // ARIA
  "aria-allowed-attr": "aria",
  "aria-valid-attr": "aria",
  "aria-valid-attr-value": "aria",
  "aria-required-attr": "aria",
  "aria-required-children": "aria",
  "aria-required-parent": "aria",
  "aria-hidden-focus": "aria",
  "aria-input-field-name": "aria",
  "aria-toggle-field-name": "aria",
  "aria-command-name": "aria",

  // Tables
  "td-headers-attr": "tables",
  "th-has-data-cells": "tables",
  "scope-attr-valid": "tables",
  "table-duplicate-name": "tables",

  // Lists
  list: "lists",
  listitem: "lists",
  "definition-list": "lists",
  dlitem: "lists",

  // Headings
  "heading-order": "headings",
  "empty-heading": "headings",
  "p-as-heading": "headings",

  // Structure
  region: "structure",
  duplicate: "structure",
  "duplicate-id": "structure",
  "duplicate-id-active": "structure",
  "duplicate-id-aria": "structure",
  tabindex: "structure",
  "nested-interactive": "structure",

  // Media
  "video-caption": "media",
  "audio-caption": "media",
  "no-autoplay-audio": "media",

  // Frames
  "frame-title": "frames",
  "frame-title-unique": "frames",

  // Landmarks (page-level)
  "landmark-one-main": "landmarks",
  "landmark-unique": "landmarks",
  "landmark-banner-is-top-level": "landmarks",

  // Document (page-level)
  "document-title": "document",
  "html-has-lang": "document",
  "html-lang-valid": "document",
  bypass: "document",
};

/**
 * Get category for a rule
 */
function getCategory(ruleId: string): string {
  return RULE_CATEGORIES[ruleId] ?? "other";
}

/**
 * Escape HTML for use in JSX string
 */
function escapeForJsx(html: string): string {
  return html.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
}

/**
 * Generate a story file content
 */
function generateStoryContent(rule: AxeRuleMetadata, fixtures: ExtractedFixture[]): string {
  const violations = fixtures.filter((f) => f.type === "violation");
  const passes = fixtures.filter((f) => f.type === "pass");

  const lines: string[] = [
    "// Auto-generated by a11y-stories generate - DO NOT EDIT MANUALLY",
    `// Source: axe-core rule "${rule.ruleId}"`,
    `// Generated: ${new Date().toISOString()}`,
    "",
    'import type { Meta, StoryObj } from "@storybook/react";',
    "",
    "/**",
    ` * ## Rule: \`${rule.ruleId}\``,
    " *",
    ` * ${rule.description}`,
    " *",
    ` * - **WCAG:** ${rule.wcagCriteria.join(", ") || "N/A"}`,
    ` * - **Level:** ${rule.wcagLevel || "N/A"}`,
    ` * - **Impact:** ${rule.impact}`,
    ` * - **Tags:** ${rule.tags.slice(0, 5).join(", ")}`,
    ` * - **Reference:** [${rule.ruleId}](${rule.helpUrl})`,
    " */",
    "const meta: Meta = {",
    `  title: "A11y Violations/${getCategory(rule.ruleId)}/${rule.ruleId}",`,
    "  parameters: {",
    "    a11yReference: {",
    `      ruleId: "${rule.ruleId}",`,
    `      expectedViolations: ["${rule.ruleId}"],`,
    `      wcag: ${JSON.stringify(rule.wcagCriteria)},`,
    `      impact: "${rule.impact}",`,
    `      helpUrl: "${rule.helpUrl}",`,
    "    },",
    "    docs: {",
    "      description: {",
    `        component: "${rule.description.replace(/"/g, '\\"')}",`,
    "      },",
    "    },",
    "  },",
    "};",
    "",
    "export default meta;",
    "",
    "type Story = StoryObj;",
    "",
  ];

  // Generate violation stories
  violations.forEach((fixture, index) => {
    const storyName = violations.length === 1 ? "Violation" : `Violation${index + 1}`;

    lines.push(
      "/**",
      ` * ❌ VIOLATION: ${fixture.description}`,
      " */",
      `export const ${storyName}: Story = {`,
      "  render: () => (",
      "    <div",
      "      dangerouslySetInnerHTML={{",
      `        __html: \`${escapeForJsx(fixture.html)}\`,`,
      "      }}",
      "    />",
      "  ),",
      "  parameters: {",
      "    a11yReference: {",
      "      shouldViolate: true,",
      `      ruleId: "${rule.ruleId}",`,
      `      description: "${fixture.description.replace(/"/g, '\\"')}",`,
      "    },",
      "  },",
      "};",
      ""
    );
  });

  // Generate pass stories
  passes.forEach((fixture, index) => {
    const storyName = passes.length === 1 ? "Pass" : `Pass${index + 1}`;

    lines.push(
      "/**",
      ` * ✅ PASS: ${fixture.description}`,
      " */",
      `export const ${storyName}: Story = {`,
      "  render: () => (",
      "    <div",
      "      dangerouslySetInnerHTML={{",
      `        __html: \`${escapeForJsx(fixture.html)}\`,`,
      "      }}",
      "    />",
      "  ),",
      "  parameters: {",
      "    a11yReference: {",
      "      shouldViolate: false,",
      `      ruleId: "${rule.ruleId}",`,
      `      description: "${fixture.description.replace(/"/g, '\\"')}",`,
      "    },",
      "  },",
      "};",
      ""
    );
  });

  return lines.join("\n");
}

/**
 * Generate story file for a single rule
 */
export function generateStoryForRule(
  rule: AxeRuleMetadata,
  fixtures: ExtractedFixture[],
  options: StoryGeneratorOptions
): GeneratedStory {
  const category = getCategory(rule.ruleId);
  const fileName = `${rule.ruleId}.stories.tsx`;
  const filePath = join(category, fileName);
  const fullPath = join(options.outputDir, filePath);

  const violations = fixtures.filter((f) => f.type === "violation");
  const passes = fixtures.filter((f) => f.type === "pass");

  const result: GeneratedStory = {
    ruleId: rule.ruleId,
    filePath,
    category,
    violationCount: violations.length,
    passCount: passes.length,
    written: false,
  };

  // Skip if no fixtures
  if (fixtures.length === 0) {
    return result;
  }

  // Check if file exists
  if (!options.force && existsSync(fullPath)) {
    return result;
  }

  // Generate content
  const content = generateStoryContent(rule, fixtures);

  // Write file (unless dry run)
  if (!options.dryRun) {
    mkdirSync(dirname(fullPath), { recursive: true });
    writeFileSync(fullPath, content);
    result.written = true;
  } else {
    result.written = true; // Mark as "would be written"
  }

  return result;
}

/**
 * Generate stories for multiple rules
 */
export function generateStories(
  rules: AxeRuleMetadata[],
  fixturesMap: Map<string, ExtractedFixture[]>,
  options: StoryGeneratorOptions
): GenerationResult {
  const result: GenerationResult = {
    stories: [],
    totalStories: 0,
    filesWritten: 0,
    filesSkipped: 0,
    errors: [],
  };

  for (const rule of rules) {
    try {
      const fixtures = fixturesMap.get(rule.ruleId) ?? [];
      const story = generateStoryForRule(rule, fixtures, options);
      result.stories.push(story);

      if (story.written) {
        result.filesWritten++;
        result.totalStories += story.violationCount + story.passCount;
      } else if (fixtures.length > 0) {
        result.filesSkipped++;
      }
    } catch (error) {
      result.errors.push(
        `Error generating story for ${rule.ruleId}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  return result;
}

/**
 * Generate an index file that exports all generated stories
 */
export function generateIndexFile(
  stories: GeneratedStory[],
  outputDir: string,
  dryRun = false
): void {
  const lines: string[] = [
    "// Auto-generated index of all a11y reference stories",
    `// Generated: ${new Date().toISOString()}`,
    "",
    "// This file is for reference only - Storybook auto-discovers stories",
    "// based on the stories glob pattern in .storybook/main.ts",
    "",
    `export const GENERATED_STORY_COUNT = ${stories.length};`,
    "",
    "export const GENERATED_RULES = [",
    ...stories.map((s) => `  "${s.ruleId}",`),
    "];",
    "",
    "export const STORIES_BY_CATEGORY = {",
  ];

  // Group by category
  const byCategory = new Map<string, GeneratedStory[]>();
  for (const story of stories) {
    const existing = byCategory.get(story.category) ?? [];
    existing.push(story);
    byCategory.set(story.category, existing);
  }

  for (const [category, categoryStories] of byCategory) {
    lines.push(`  "${category}": [`);
    for (const story of categoryStories) {
      lines.push(`    "${story.ruleId}",`);
    }
    lines.push("  ],");
  }

  lines.push("};", "");

  const content = lines.join("\n");
  const indexPath = join(outputDir, "index.ts");

  if (!dryRun) {
    mkdirSync(outputDir, { recursive: true });
    writeFileSync(indexPath, content);
  }
}
