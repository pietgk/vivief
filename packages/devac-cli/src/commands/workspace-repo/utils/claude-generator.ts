/**
 * CLAUDE.md Generator
 *
 * Generates workspace-level CLAUDE.md content from parsed AGENTS.md files.
 * Supports auto-generated sections with markers to preserve manual content.
 */

import type { ParsedAgentsMd } from "./agents-parser.js";

/**
 * Section markers for auto-generated content
 */
export const MARKERS = {
  OVERVIEW: {
    start: "<!-- BEGIN AUTO-GENERATED:OVERVIEW -->",
    end: "<!-- END AUTO-GENERATED:OVERVIEW -->",
  },
  PROJECTS: {
    start: "<!-- BEGIN AUTO-GENERATED:PROJECTS -->",
    end: "<!-- END AUTO-GENERATED:PROJECTS -->",
  },
  COMMANDS: {
    start: "<!-- BEGIN AUTO-GENERATED:COMMANDS -->",
    end: "<!-- END AUTO-GENERATED:COMMANDS -->",
  },
  TECH: {
    start: "<!-- BEGIN AUTO-GENERATED:TECH -->",
    end: "<!-- END AUTO-GENERATED:TECH -->",
  },
} as const;

/**
 * Workspace definition from workspace.yaml
 */
export interface WorkspaceDefinition {
  /** Workspace name */
  name: string;
  /** Workspace description */
  description?: string;
  /** List of repositories */
  repos: WorkspaceRepoDefinition[];
}

/**
 * Repository definition in workspace.yaml
 */
export interface WorkspaceRepoDefinition {
  /** Relative path to the repository */
  path: string;
  /** Description of the repository */
  description?: string;
  /** Whether this is the primary repository */
  primary?: boolean;
  /** Whether to exclude from documentation */
  excludeFromDocs?: boolean;
}

/**
 * Options for generating CLAUDE.md
 */
export interface GenerateOptions {
  /** Workspace definition */
  workspace: WorkspaceDefinition;
  /** Parsed AGENTS.md files */
  parsedAgentsMd: ParsedAgentsMd[];
  /** Existing CLAUDE.md content (to preserve manual sections) */
  existingContent?: string;
  /** Include commands section */
  includeCommands?: boolean;
  /** Include tech stack section */
  includeTechStack?: boolean;
}

/**
 * Result of generating CLAUDE.md
 */
export interface GenerateResult {
  /** Generated content */
  content: string;
  /** Sections that were auto-generated */
  autoGeneratedSections: string[];
  /** Sections that were preserved from existing content */
  preservedSections: string[];
}

/**
 * Extract content outside of markers
 */
function extractNonMarkedContent(content: string): {
  before: string;
  after: string;
  markedSections: Map<string, string>;
} {
  const markedSections = new Map<string, string>();
  let currentContent = content;

  // Extract each marked section
  for (const [name, markers] of Object.entries(MARKERS)) {
    const startIdx = currentContent.indexOf(markers.start);
    const endIdx = currentContent.indexOf(markers.end);

    if (startIdx !== -1 && endIdx !== -1 && endIdx > startIdx) {
      const markedContent = currentContent.slice(startIdx + markers.start.length, endIdx);
      markedSections.set(name, markedContent);

      // Remove the marked section from content
      currentContent = `${currentContent.slice(0, startIdx)}__PLACEHOLDER_${name}__${currentContent.slice(endIdx + markers.end.length)}`;
    }
  }

  // Find where content naturally splits
  const firstPlaceholder = currentContent.indexOf("__PLACEHOLDER_");
  if (firstPlaceholder === -1) {
    return { before: content, after: "", markedSections };
  }

  // Find last placeholder
  let lastPlaceholderEnd = 0;
  for (const name of Object.keys(MARKERS)) {
    const placeholder = `__PLACEHOLDER_${name}__`;
    const idx = currentContent.indexOf(placeholder);
    if (idx !== -1) {
      lastPlaceholderEnd = Math.max(lastPlaceholderEnd, idx + placeholder.length);
    }
  }

  return {
    before: currentContent.slice(0, firstPlaceholder),
    after: currentContent.slice(lastPlaceholderEnd),
    markedSections,
  };
}

/**
 * Generate the overview section
 */
function generateOverview(workspace: WorkspaceDefinition, parsed: ParsedAgentsMd[]): string {
  const lines: string[] = [];

  lines.push(MARKERS.OVERVIEW.start);
  lines.push("");
  lines.push("## Workspace Overview");
  lines.push("");

  if (workspace.description) {
    lines.push(workspace.description);
  } else {
    const repoCount = workspace.repos.filter((r) => !r.excludeFromDocs).length;
    lines.push(`This workspace contains ${repoCount} repositories.`);
  }
  lines.push("");

  // Summary stats
  const foundDocs = parsed.filter((p) => p.found).length;
  if (foundDocs > 0) {
    lines.push(
      `**Documentation:** ${foundDocs}/${parsed.length} repositories have AGENTS.md files.`
    );
    lines.push("");
  }

  lines.push(MARKERS.OVERVIEW.end);

  return lines.join("\n");
}

/**
 * Generate the projects section
 */
function generateProjects(workspace: WorkspaceDefinition, parsed: ParsedAgentsMd[]): string {
  const lines: string[] = [];

  lines.push(MARKERS.PROJECTS.start);
  lines.push("");
  lines.push("## Projects Structure");
  lines.push("");

  // Create a map for quick lookup
  const parsedMap = new Map<string, ParsedAgentsMd>();
  for (const p of parsed) {
    parsedMap.set(p.repoName, p);
  }

  for (const repo of workspace.repos) {
    if (repo.excludeFromDocs) continue;

    const repoName = repo.path.replace(/\/$/, "").split("/").pop() || repo.path;
    const parsedRepo = parsedMap.get(repoName);

    lines.push(`### ${repo.path}/`);

    // Description
    if (repo.description) {
      lines.push(`**${repo.description}**`);
    } else if (parsedRepo?.description) {
      // Truncate long descriptions
      const desc =
        parsedRepo.description.length > 200
          ? `${parsedRepo.description.slice(0, 197)}...`
          : parsedRepo.description;
      lines.push(`**${desc}**`);
    }
    lines.push("");

    // Stack info
    if (parsedRepo?.stack) {
      const stackParts: string[] = [];
      if (parsedRepo.stack.languages.length > 0) {
        stackParts.push(parsedRepo.stack.languages.join(", "));
      }
      if (parsedRepo.stack.frameworks.length > 0) {
        stackParts.push(parsedRepo.stack.frameworks.join(", "));
      }
      if (parsedRepo.stack.databases.length > 0) {
        stackParts.push(parsedRepo.stack.databases.join(", "));
      }
      if (stackParts.length > 0) {
        lines.push(`- **Stack:** ${stackParts.join(" | ")}`);
      }
    }

    // Key commands
    if (parsedRepo?.commands) {
      const cmds: string[] = [];
      if (parsedRepo.commands.dev.length > 0) {
        cmds.push(`\`${parsedRepo.commands.dev[0]}\``);
      }
      if (parsedRepo.commands.test.length > 0) {
        cmds.push(`\`${parsedRepo.commands.test[0]}\``);
      }
      if (cmds.length > 0) {
        lines.push(`- **Commands:** ${cmds.join(", ")}`);
      }
    }

    // Reference to docs
    if (parsedRepo?.found) {
      lines.push(`- **Docs:** @${repo.path}/AGENTS.md`);
    }

    lines.push("");
  }

  lines.push(MARKERS.PROJECTS.end);

  return lines.join("\n");
}

/**
 * Generate the commands section
 */
function generateCommands(workspace: WorkspaceDefinition, parsed: ParsedAgentsMd[]): string {
  const lines: string[] = [];

  lines.push(MARKERS.COMMANDS.start);
  lines.push("");
  lines.push("## Essential Commands by Project");
  lines.push("");

  // Create a map for quick lookup
  const parsedMap = new Map<string, ParsedAgentsMd>();
  for (const p of parsed) {
    parsedMap.set(p.repoName, p);
  }

  for (const repo of workspace.repos) {
    if (repo.excludeFromDocs) continue;

    const repoName = repo.path.replace(/\/$/, "").split("/").pop() || repo.path;
    const parsedRepo = parsedMap.get(repoName);

    if (!parsedRepo?.commands) continue;

    const cmds = parsedRepo.commands;
    const hasCmds = cmds.dev.length > 0 || cmds.test.length > 0 || cmds.build.length > 0;
    if (!hasCmds) continue;

    lines.push(`### ${repo.path}`);
    lines.push("");
    lines.push("```bash");

    if (cmds.dev.length > 0) {
      lines.push("# Development");
      for (const cmd of cmds.dev.slice(0, 3)) {
        lines.push(cmd);
      }
    }
    if (cmds.test.length > 0) {
      lines.push("# Testing");
      for (const cmd of cmds.test.slice(0, 2)) {
        lines.push(cmd);
      }
    }
    if (cmds.build.length > 0) {
      lines.push("# Build");
      for (const cmd of cmds.build.slice(0, 2)) {
        lines.push(cmd);
      }
    }

    lines.push("```");
    lines.push("");
  }

  lines.push(MARKERS.COMMANDS.end);

  return lines.join("\n");
}

/**
 * Generate the tech stack section
 */
function generateTechStack(parsed: ParsedAgentsMd[]): string {
  const lines: string[] = [];

  lines.push(MARKERS.TECH.start);
  lines.push("");
  lines.push("## Key Technologies");
  lines.push("");

  // Aggregate all technologies
  const languages = new Set<string>();
  const frameworks = new Set<string>();
  const databases = new Set<string>();

  for (const p of parsed) {
    if (p.stack) {
      for (const lang of p.stack.languages) {
        languages.add(lang);
      }
      for (const fw of p.stack.frameworks) {
        frameworks.add(fw);
      }
      for (const db of p.stack.databases) {
        databases.add(db);
      }
    }
  }

  if (languages.size > 0) {
    lines.push(`- **Languages:** ${Array.from(languages).join(", ")}`);
  }
  if (frameworks.size > 0) {
    lines.push(`- **Frameworks:** ${Array.from(frameworks).join(", ")}`);
  }
  if (databases.size > 0) {
    lines.push(`- **Databases:** ${Array.from(databases).join(", ")}`);
  }

  lines.push("");
  lines.push(MARKERS.TECH.end);

  return lines.join("\n");
}

/**
 * Generate the default header for CLAUDE.md
 */
function generateHeader(workspace: WorkspaceDefinition): string {
  const lines: string[] = [];

  lines.push("# AGENTS.md");
  lines.push("");
  lines.push(
    `This file provides guidance to AI coding agents when working with code in the ${workspace.name} workspace.`
  );
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate CLAUDE.md content
 */
export function generateClaudeMd(options: GenerateOptions): GenerateResult {
  const {
    workspace,
    parsedAgentsMd,
    existingContent,
    includeCommands = true,
    includeTechStack = true,
  } = options;

  const autoGeneratedSections: string[] = [];
  const preservedSections: string[] = [];

  // Parse existing content if provided
  let beforeContent = "";
  let afterContent = "";

  if (existingContent) {
    const extracted = extractNonMarkedContent(existingContent);
    beforeContent = extracted.before;
    afterContent = extracted.after;

    // Note which sections had existing content
    for (const [name] of extracted.markedSections) {
      preservedSections.push(name);
    }
  }

  // Generate auto-generated sections
  const overview = generateOverview(workspace, parsedAgentsMd);
  autoGeneratedSections.push("OVERVIEW");

  const projects = generateProjects(workspace, parsedAgentsMd);
  autoGeneratedSections.push("PROJECTS");

  let commands = "";
  if (includeCommands) {
    commands = generateCommands(workspace, parsedAgentsMd);
    autoGeneratedSections.push("COMMANDS");
  }

  let techStack = "";
  if (includeTechStack) {
    techStack = generateTechStack(parsedAgentsMd);
    autoGeneratedSections.push("TECH");
  }

  // Assemble content
  const parts: string[] = [];

  // Use existing header or generate new one
  if (beforeContent.trim()) {
    parts.push(beforeContent.trim());
  } else {
    parts.push(generateHeader(workspace));
  }

  parts.push("");
  parts.push(overview);
  parts.push("");
  parts.push(projects);

  if (commands) {
    parts.push("");
    parts.push(commands);
  }

  if (techStack) {
    parts.push("");
    parts.push(techStack);
  }

  // Add preserved content after markers
  if (afterContent.trim()) {
    parts.push("");
    parts.push(afterContent.trim());
  }

  return {
    content: parts.join("\n"),
    autoGeneratedSections,
    preservedSections,
  };
}

/**
 * Check if content has auto-generated markers
 */
export function hasAutoGeneratedMarkers(content: string): boolean {
  for (const markers of Object.values(MARKERS)) {
    if (content.includes(markers.start) && content.includes(markers.end)) {
      return true;
    }
  }
  return false;
}

/**
 * Get the list of auto-generated section names in content
 */
export function getAutoGeneratedSections(content: string): string[] {
  const sections: string[] = [];
  for (const [name, markers] of Object.entries(MARKERS)) {
    if (content.includes(markers.start) && content.includes(markers.end)) {
      sections.push(name);
    }
  }
  return sections;
}
