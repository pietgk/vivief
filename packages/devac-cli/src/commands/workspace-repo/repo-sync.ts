/**
 * Workspace Repo Sync Command
 *
 * Syncs CLAUDE.md content by:
 * 1. Reading all AGENTS.md files from discovered repos
 * 2. Parsing and aggregating into sections
 * 3. Preserving manually-written content outside markers
 * 4. Updating auto-generated sections
 */

import * as fs from "node:fs/promises";
import * as path from "node:path";
import { type WorkspaceInfo, discoverWorkspace } from "@pietgk/devac-core";
import YAML from "yaml";
import { type ParsedAgentsMd, parseAllAgentsMd } from "./utils/agents-parser.js";
import {
  type WorkspaceDefinition,
  type WorkspaceRepoDefinition,
  generateClaudeMd,
  getAutoGeneratedSections,
} from "./utils/claude-generator.js";

/**
 * Options for repo sync command
 */
export interface RepoSyncOptions {
  /** Workspace path */
  workspacePath: string;
  /** Path to workspace repo (auto-detected if not provided) */
  repoPath?: string;
  /** Dry run - show what would change without writing */
  dryRun?: boolean;
  /** Output as JSON */
  json?: boolean;
}

/**
 * Result of repo sync command
 */
export interface RepoSyncResult {
  /** Whether the command succeeded */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Path to the workspace repo */
  repoPath: string;
  /** Path to CLAUDE.md */
  claudeMdPath: string;
  /** Repos that were processed */
  reposProcessed: string[];
  /** Sections that were updated */
  sectionsUpdated: string[];
  /** Sections that were preserved */
  sectionsPreserved: string[];
  /** Whether content changed */
  contentChanged: boolean;
  /** Diff preview (for dry run) */
  diffPreview?: string;
  /** Formatted output */
  formatted?: string;
}

/**
 * Find workspace repo in the workspace directory
 */
async function findWorkspaceRepo(workspacePath: string): Promise<string | null> {
  const entries = await fs.readdir(workspacePath, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory() && entry.name.endsWith("-workspace")) {
      const repoPath = path.join(workspacePath, entry.name);
      const workspaceYamlPath = path.join(repoPath, "workspace.yaml");

      try {
        await fs.access(workspaceYamlPath);
        return repoPath;
      } catch {
        // Not a workspace repo
      }
    }
  }

  return null;
}

/**
 * Load workspace.yaml definition
 */
async function loadWorkspaceYaml(repoPath: string): Promise<WorkspaceDefinition | null> {
  const workspaceYamlPath = path.join(repoPath, "workspace.yaml");

  try {
    const content = await fs.readFile(workspaceYamlPath, "utf-8");
    const parsed = YAML.parse(content);

    // Normalize repo definitions
    const repos: WorkspaceRepoDefinition[] = (parsed.repos || []).map(
      (repo: Record<string, unknown>) => ({
        path: repo.path as string,
        description: repo.description as string | undefined,
        primary: repo.primary as boolean | undefined,
        excludeFromDocs: repo.exclude_from_docs as boolean | undefined,
      })
    );

    return {
      name: parsed.name || "workspace",
      description: parsed.description,
      repos,
    };
  } catch {
    return null;
  }
}

/**
 * Simple diff preview between old and new content
 */
function createDiffPreview(oldContent: string, newContent: string): string {
  const oldLines = oldContent.split("\n");
  const newLines = newContent.split("\n");

  const lines: string[] = [];
  lines.push("Changes preview:");
  lines.push("‚îÄ".repeat(60));

  // Simple line-by-line comparison (not a full diff algorithm)
  const maxLines = Math.max(oldLines.length, newLines.length);
  let changes = 0;
  const contextLines = 3;
  let lastChangeLine = -contextLines - 1;

  for (let i = 0; i < maxLines; i++) {
    const oldLine = oldLines[i] || "";
    const newLine = newLines[i] || "";

    if (oldLine !== newLine) {
      // Show context before change
      if (i - lastChangeLine > contextLines * 2) {
        if (changes > 0) {
          lines.push("...");
        }
        for (let j = Math.max(0, i - contextLines); j < i; j++) {
          lines.push(`  ${j + 1}: ${oldLines[j] || ""}`);
        }
      }

      if (oldLine && !newLine) {
        lines.push(`- ${i + 1}: ${oldLine}`);
      } else if (!oldLine && newLine) {
        lines.push(`+ ${i + 1}: ${newLine}`);
      } else {
        lines.push(`- ${i + 1}: ${oldLine}`);
        lines.push(`+ ${i + 1}: ${newLine}`);
      }

      changes++;
      lastChangeLine = i;
    }
  }

  if (changes === 0) {
    lines.push("No changes detected");
  } else {
    lines.push("‚îÄ".repeat(60));
    lines.push(`${changes} line(s) changed`);
  }

  return lines.join("\n");
}

/**
 * Execute repo sync command
 */
export async function repoSyncCommand(options: RepoSyncOptions): Promise<RepoSyncResult> {
  const { workspacePath, repoPath: customRepoPath, dryRun = false } = options;

  const resolvedWorkspacePath = path.resolve(workspacePath);

  const result: RepoSyncResult = {
    success: false,
    repoPath: "",
    claudeMdPath: "",
    reposProcessed: [],
    sectionsUpdated: [],
    sectionsPreserved: [],
    contentChanged: false,
  };

  try {
    // Find workspace repo
    const repoPath = customRepoPath
      ? path.resolve(customRepoPath)
      : await findWorkspaceRepo(resolvedWorkspacePath);

    if (!repoPath) {
      return {
        ...result,
        error: "No workspace repo found. Run 'devac workspace repo init' first.",
      };
    }

    result.repoPath = repoPath;
    result.claudeMdPath = path.join(repoPath, "CLAUDE.md");

    // Load workspace definition
    const workspaceDefinition = await loadWorkspaceYaml(repoPath);
    if (!workspaceDefinition) {
      return {
        ...result,
        error: `workspace.yaml not found or invalid in ${repoPath}`,
      };
    }

    // Discover repos
    const workspaceInfo: WorkspaceInfo = await discoverWorkspace(resolvedWorkspacePath);

    // Map repo paths from workspace.yaml to actual paths
    const repoPaths: string[] = [];
    for (const repoDef of workspaceDefinition.repos) {
      if (repoDef.excludeFromDocs) continue;

      const repoFullPath = path.join(resolvedWorkspacePath, repoDef.path);
      try {
        await fs.access(repoFullPath);
        repoPaths.push(repoFullPath);
        result.reposProcessed.push(repoDef.path);
      } catch {
        // Repo doesn't exist, skip
      }
    }

    // Also include repos not in workspace.yaml but discovered
    for (const repo of workspaceInfo.repos) {
      const isInYaml = workspaceDefinition.repos.some(
        (r) => path.join(resolvedWorkspacePath, r.path) === repo.path
      );
      if (!isInYaml && !repoPaths.includes(repo.path)) {
        repoPaths.push(repo.path);
        result.reposProcessed.push(repo.name);
      }
    }

    // Parse AGENTS.md from all repos
    const parsedAgentsMd: ParsedAgentsMd[] = await parseAllAgentsMd(repoPaths);

    // Read existing CLAUDE.md
    let existingContent: string | undefined;
    try {
      existingContent = await fs.readFile(result.claudeMdPath, "utf-8");
      result.sectionsPreserved = getAutoGeneratedSections(existingContent);
    } catch {
      // File doesn't exist
    }

    // Generate new content
    const generateResult = generateClaudeMd({
      workspace: workspaceDefinition,
      parsedAgentsMd,
      existingContent,
      includeCommands: true,
      includeTechStack: true,
    });

    result.sectionsUpdated = generateResult.autoGeneratedSections;

    // Check if content changed
    result.contentChanged = existingContent !== generateResult.content;

    if (dryRun) {
      if (existingContent) {
        result.diffPreview = createDiffPreview(existingContent, generateResult.content);
      } else {
        result.diffPreview = `New file will be created:\n${generateResult.content.slice(0, 500)}\n...`;
      }
    } else if (result.contentChanged) {
      // Write updated content
      await fs.writeFile(result.claudeMdPath, generateResult.content, "utf-8");
    }

    result.success = true;
    result.formatted = formatResult(result, dryRun);

    return result;
  } catch (error) {
    return {
      ...result,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Format result for display
 */
function formatResult(result: RepoSyncResult, dryRun: boolean): string {
  const lines: string[] = [];

  if (dryRun) {
    lines.push("Dry run - no changes written");
    lines.push("");
  }

  if (result.contentChanged) {
    lines.push(dryRun ? "Would update CLAUDE.md" : "‚úì CLAUDE.md updated");
  } else {
    lines.push("‚úì CLAUDE.md is already up to date");
  }

  lines.push("");
  lines.push("Processed:");
  lines.push(`  Workspace repo: ${result.repoPath}`);
  lines.push(`  Repositories: ${result.reposProcessed.length}`);

  if (result.reposProcessed.length > 0) {
    lines.push("");
    lines.push("Repos processed:");
    for (const repo of result.reposProcessed) {
      lines.push(`  üì¶ ${repo}`);
    }
  }

  if (result.sectionsUpdated.length > 0) {
    lines.push("");
    lines.push("Sections updated:");
    for (const section of result.sectionsUpdated) {
      lines.push(`  ‚úèÔ∏è  ${section}`);
    }
  }

  if (dryRun && result.diffPreview) {
    lines.push("");
    lines.push(result.diffPreview);
  }

  return lines.join("\n");
}
