/**
 * Workspace Repo Status Command
 *
 * Shows the status of the workspace repo including:
 * - Workspace repo location and git status
 * - Symlink status
 * - CLAUDE.md generation status
 * - workspace.yaml content summary
 */

import { execSync } from "node:child_process";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import YAML from "yaml";
import { parseAllAgentsMd, summarizeAgentsMd } from "./utils/agents-parser.js";
import { getAutoGeneratedSections } from "./utils/claude-generator.js";

/**
 * Options for repo status command
 */
export interface RepoStatusOptions {
  /** Workspace path */
  workspacePath: string;
  /** Path to workspace repo (auto-detected if not provided) */
  repoPath?: string;
  /** Output as JSON */
  json?: boolean;
}

/**
 * Symlink status information
 */
export interface SymlinkStatus {
  /** Target path (in workspace root) */
  target: string;
  /** Whether the symlink exists */
  exists: boolean;
  /** Whether it points to the correct source */
  valid: boolean;
  /** Actual link target (if exists) */
  actualTarget?: string;
  /** Expected link target */
  expectedTarget: string;
}

/**
 * Git status information
 */
export interface GitStatus {
  /** Whether the repo is a git repo */
  isGitRepo: boolean;
  /** Current branch */
  branch?: string;
  /** Whether there are uncommitted changes */
  hasUncommittedChanges?: boolean;
  /** Number of uncommitted files */
  uncommittedFiles?: number;
  /** Whether there are unpushed commits */
  hasUnpushedCommits?: boolean;
}

/**
 * CLAUDE.md status
 */
export interface ClaudeMdStatus {
  /** Whether CLAUDE.md exists */
  exists: boolean;
  /** File size in bytes */
  size?: number;
  /** Last modified time */
  lastModified?: string;
  /** Auto-generated sections present */
  autoGeneratedSections: string[];
  /** Whether sync is needed */
  syncNeeded?: boolean;
}

/**
 * Workspace.yaml summary
 */
export interface WorkspaceYamlSummary {
  /** Whether workspace.yaml exists */
  exists: boolean;
  /** Workspace name */
  name?: string;
  /** Number of repos defined */
  repoCount?: number;
  /** Repo names */
  repos?: string[];
}

/**
 * Result of repo status command
 */
export interface RepoStatusResult {
  /** Whether the command succeeded */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Whether a workspace repo was found */
  found: boolean;
  /** Path to the workspace repo */
  repoPath?: string;
  /** Git status */
  git?: GitStatus;
  /** Symlink status */
  symlinks?: SymlinkStatus[];
  /** CLAUDE.md status */
  claudeMd?: ClaudeMdStatus;
  /** workspace.yaml summary */
  workspaceYaml?: WorkspaceYamlSummary;
  /** AGENTS.md discovery summary */
  agentsMdSummary?: {
    total: number;
    found: number;
    withStack: number;
    withCommands: number;
  };
  /** Formatted output */
  formatted?: string;
}

/**
 * Find workspace repo in the workspace directory
 */
async function findWorkspaceRepo(workspacePath: string): Promise<string | null> {
  const entries = await fs.readdir(workspacePath, { withFileTypes: true });

  for (const entry of entries) {
    if (entry.isDirectory() && entry.name.endsWith("-workspace")) {
      const repoPath = path.join(workspacePath, entry.name);
      const workspaceYamlPath = path.join(repoPath, "workspace.yaml");

      try {
        await fs.access(workspaceYamlPath);
        return repoPath;
      } catch {
        // Not a workspace repo
      }
    }
  }

  return null;
}

/**
 * Get git status for the workspace repo
 */
async function getGitStatus(repoPath: string): Promise<GitStatus> {
  const status: GitStatus = { isGitRepo: false };

  try {
    // Check if it's a git repo
    await fs.access(path.join(repoPath, ".git"));
    status.isGitRepo = true;

    // Get current branch
    try {
      const branch = execSync("git rev-parse --abbrev-ref HEAD", {
        cwd: repoPath,
        stdio: ["pipe", "pipe", "pipe"],
        encoding: "utf-8",
      }).trim();
      status.branch = branch;
    } catch {
      // Not on a branch
    }

    // Check for uncommitted changes
    try {
      const statusOutput = execSync("git status --porcelain", {
        cwd: repoPath,
        stdio: ["pipe", "pipe", "pipe"],
        encoding: "utf-8",
      }).trim();
      const changedFiles = statusOutput.split("\n").filter((l) => l.trim());
      status.hasUncommittedChanges = changedFiles.length > 0;
      status.uncommittedFiles = changedFiles.length;
    } catch {
      // Couldn't get status
    }

    // Check for unpushed commits
    try {
      const unpushed = execSync("git log @{u}..HEAD --oneline 2>/dev/null || echo ''", {
        cwd: repoPath,
        stdio: ["pipe", "pipe", "pipe"],
        encoding: "utf-8",
        shell: "/bin/bash",
      }).trim();
      status.hasUnpushedCommits = unpushed.length > 0;
    } catch {
      // No upstream configured
    }
  } catch {
    // Not a git repo
  }

  return status;
}

/**
 * Get symlink status
 */
async function getSymlinkStatus(workspacePath: string, repoPath: string): Promise<SymlinkStatus[]> {
  const workspaceRepoName = path.basename(repoPath);
  const symlinks: SymlinkStatus[] = [];

  const symlinkConfigs = [
    { source: "CLAUDE.md", target: path.join(workspacePath, "CLAUDE.md") },
    { source: ".agent-os", target: path.join(workspacePath, ".agent-os") },
  ];

  for (const config of symlinkConfigs) {
    const expectedTarget = `${workspaceRepoName}/${config.source}`;
    const status: SymlinkStatus = {
      target: config.target,
      exists: false,
      valid: false,
      expectedTarget,
    };

    try {
      const stats = await fs.lstat(config.target);
      status.exists = true;

      if (stats.isSymbolicLink()) {
        const actualTarget = await fs.readlink(config.target);
        status.actualTarget = actualTarget;
        status.valid = actualTarget === expectedTarget;
      }
    } catch {
      // Doesn't exist
    }

    symlinks.push(status);
  }

  return symlinks;
}

/**
 * Get CLAUDE.md status
 */
async function getClaudeMdStatus(repoPath: string): Promise<ClaudeMdStatus> {
  const claudeMdPath = path.join(repoPath, "CLAUDE.md");
  const status: ClaudeMdStatus = {
    exists: false,
    autoGeneratedSections: [],
  };

  try {
    const stats = await fs.stat(claudeMdPath);
    status.exists = true;
    status.size = stats.size;
    status.lastModified = stats.mtime.toISOString();

    const content = await fs.readFile(claudeMdPath, "utf-8");
    status.autoGeneratedSections = getAutoGeneratedSections(content);
  } catch {
    // File doesn't exist
  }

  return status;
}

/**
 * Get workspace.yaml summary
 */
async function getWorkspaceYamlSummary(repoPath: string): Promise<WorkspaceYamlSummary> {
  const workspaceYamlPath = path.join(repoPath, "workspace.yaml");
  const summary: WorkspaceYamlSummary = { exists: false };

  try {
    const content = await fs.readFile(workspaceYamlPath, "utf-8");
    const parsed = YAML.parse(content);

    summary.exists = true;
    summary.name = parsed.name;

    if (parsed.repos && Array.isArray(parsed.repos)) {
      summary.repoCount = parsed.repos.length;
      summary.repos = parsed.repos.map((r: Record<string, string>) => r.path);
    }
  } catch {
    // File doesn't exist or is invalid
  }

  return summary;
}

/**
 * Execute repo status command
 */
export async function repoStatusCommand(options: RepoStatusOptions): Promise<RepoStatusResult> {
  const { workspacePath, repoPath: customRepoPath } = options;

  const resolvedWorkspacePath = path.resolve(workspacePath);

  const result: RepoStatusResult = {
    success: false,
    found: false,
  };

  try {
    // Find workspace repo
    const repoPath = customRepoPath
      ? path.resolve(customRepoPath)
      : await findWorkspaceRepo(resolvedWorkspacePath);

    if (!repoPath) {
      result.success = true;
      result.found = false;
      result.formatted = formatNotFoundResult(resolvedWorkspacePath);
      return result;
    }

    result.found = true;
    result.repoPath = repoPath;

    // Get all status information
    result.git = await getGitStatus(repoPath);
    result.symlinks = await getSymlinkStatus(resolvedWorkspacePath, repoPath);
    result.claudeMd = await getClaudeMdStatus(repoPath);
    result.workspaceYaml = await getWorkspaceYamlSummary(repoPath);

    // Get AGENTS.md summary if workspace.yaml has repos
    if (result.workspaceYaml?.repos) {
      const repoPaths = result.workspaceYaml.repos.map((r) => path.join(resolvedWorkspacePath, r));
      const parsed = await parseAllAgentsMd(repoPaths);
      result.agentsMdSummary = summarizeAgentsMd(parsed);
    }

    result.success = true;
    result.formatted = formatResult(result);

    return result;
  } catch (error) {
    return {
      ...result,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Format result when no workspace repo found
 */
function formatNotFoundResult(workspacePath: string): string {
  const lines: string[] = [];

  lines.push("No workspace repo found");
  lines.push("");
  lines.push(`Workspace path: ${workspacePath}`);
  lines.push("");
  lines.push("To create a workspace repo, run:");
  lines.push("  devac workspace repo init");

  return lines.join("\n");
}

/**
 * Format result for display
 */
function formatResult(result: RepoStatusResult): string {
  const lines: string[] = [];

  lines.push("Workspace Repo Status");
  lines.push("â•".repeat(50));
  lines.push("");

  // Location
  lines.push(`ðŸ“ Location: ${result.repoPath}`);
  lines.push("");

  // Git status
  if (result.git) {
    lines.push("Git Status:");
    if (result.git.isGitRepo) {
      lines.push(`  Branch: ${result.git.branch || "unknown"}`);
      if (result.git.hasUncommittedChanges) {
        lines.push(`  âš ï¸  ${result.git.uncommittedFiles} uncommitted change(s)`);
      } else {
        lines.push("  âœ“ Working tree clean");
      }
      if (result.git.hasUnpushedCommits) {
        lines.push("  âš ï¸  Has unpushed commits");
      }
    } else {
      lines.push("  âœ— Not a git repository");
    }
    lines.push("");
  }

  // Workspace.yaml
  if (result.workspaceYaml) {
    lines.push("workspace.yaml:");
    if (result.workspaceYaml.exists) {
      lines.push(`  Name: ${result.workspaceYaml.name || "unnamed"}`);
      lines.push(`  Repos: ${result.workspaceYaml.repoCount || 0} defined`);
    } else {
      lines.push("  âœ— Not found");
    }
    lines.push("");
  }

  // CLAUDE.md status
  if (result.claudeMd) {
    lines.push("CLAUDE.md:");
    if (result.claudeMd.exists) {
      const sizeKb = result.claudeMd.size ? (result.claudeMd.size / 1024).toFixed(1) : "?";
      lines.push(`  Size: ${sizeKb} KB`);
      if (result.claudeMd.autoGeneratedSections.length > 0) {
        lines.push(
          `  Auto-generated sections: ${result.claudeMd.autoGeneratedSections.join(", ")}`
        );
      } else {
        lines.push("  âš ï¸  No auto-generated sections (run sync)");
      }
    } else {
      lines.push("  âœ— Not found");
    }
    lines.push("");
  }

  // Symlinks
  if (result.symlinks) {
    lines.push("Symlinks:");
    for (const s of result.symlinks) {
      const targetName = path.basename(s.target);
      if (!s.exists) {
        lines.push(`  âœ— ${targetName}: not installed`);
      } else if (s.valid) {
        lines.push(`  âœ“ ${targetName}: ${s.actualTarget}`);
      } else {
        lines.push(
          `  âš ï¸  ${targetName}: points to ${s.actualTarget} (expected: ${s.expectedTarget})`
        );
      }
    }
    lines.push("");
  }

  // AGENTS.md discovery
  if (result.agentsMdSummary) {
    const { total, found, withStack, withCommands } = result.agentsMdSummary;
    lines.push("AGENTS.md Discovery:");
    lines.push(`  Found: ${found}/${total} repositories`);
    lines.push(`  With stack info: ${withStack}`);
    lines.push(`  With commands: ${withCommands}`);
    lines.push("");
  }

  // Actions
  const actions: string[] = [];

  if (result.symlinks?.some((s) => !s.exists || !s.valid)) {
    actions.push("devac workspace repo install  # Fix symlinks");
  }

  if (!result.claudeMd?.exists || result.claudeMd.autoGeneratedSections.length === 0) {
    actions.push("devac workspace repo sync     # Generate/update CLAUDE.md");
  }

  if (result.git?.hasUncommittedChanges) {
    actions.push("git add . && git commit      # Commit changes");
  }

  if (actions.length > 0) {
    lines.push("Suggested actions:");
    for (const action of actions) {
      lines.push(`  ${action}`);
    }
  }

  return lines.join("\n");
}
